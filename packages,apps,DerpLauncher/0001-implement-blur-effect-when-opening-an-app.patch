From 90a726970578f3857ae1d1f56400dd5882f36b16 Mon Sep 17 00:00:00 2001
From: Hecheng Yu <kde-yyds@qq.com>
Date: Fri, 29 Nov 2024 14:45:43 +0800
Subject: [PATCH] implement blur effect when opening an app

---
 .../launcher3/QuickstepTransitionManager.java | 126 +++++++++++++-----
 1 file changed, 90 insertions(+), 36 deletions(-)

diff --git a/quickstep/src/com/android/launcher3/QuickstepTransitionManager.java b/quickstep/src/com/android/launcher3/QuickstepTransitionManager.java
index fae281a..1a84faa 100644
--- a/quickstep/src/com/android/launcher3/QuickstepTransitionManager.java
+++ b/quickstep/src/com/android/launcher3/QuickstepTransitionManager.java
@@ -176,6 +176,23 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 
+import android.view.animation.Interpolator;
+
+import android.graphics.RenderEffect;
+import android.graphics.Shader;
+import android.os.Build;
+import android.widget.FrameLayout;
+import android.view.View;
+import android.view.ViewGroup;
+class ExponentialEaseOutInterpolator implements Interpolator {
+    @Override
+    public float getInterpolation(float input) {
+        return (float) (1 - Math.pow(2, -10 * input));
+    }
+}
+
+
+
 /**
  * Manages the opening and closing app transitions from Launcher
  */
@@ -1062,51 +1079,88 @@ public class QuickstepTransitionManager implements OnDeviceProfileChangeListener
     /**
      * Returns animator that controls depth/blur of the background.
      */
-    private ObjectAnimator getBackgroundAnimator() {
-        // When launching an app from overview that doesn't map to a task, we still want to just
-        // blur the wallpaper instead of the launcher surface as well
-        boolean allowBlurringLauncher = mLauncher.getStateManager().getState() != OVERVIEW
-                && BlurUtils.supportsBlursOnWindows();
-
-        LaunchDepthController depthController = new LaunchDepthController(mLauncher);
-        ObjectAnimator backgroundRadiusAnim = ObjectAnimator.ofFloat(depthController.stateDepth,
-                        MULTI_PROPERTY_VALUE, BACKGROUND_APP.getDepth(mLauncher))
-                        .setDuration(APP_LAUNCH_DURATION);
-
-        if (allowBlurringLauncher) {
-            // Create a temporary effect layer, that lives on top of launcher, so we can apply
-            // the blur to it. The EffectLayer will be fullscreen, which will help with caching
-            // optimizations on the SurfaceFlinger side:
-            // - Results would be able to be cached as a texture
-            // - There won't be texture allocation overhead, because EffectLayers don't have
-            //   buffers
-            ViewRootImpl viewRootImpl = mLauncher.getDragLayer().getViewRootImpl();
-            SurfaceControl parent = viewRootImpl != null
-                    ? viewRootImpl.getSurfaceControl()
-                    : null;
-            SurfaceControl dimLayer = new SurfaceControl.Builder()
-                    .setName("Blur layer")
-                    .setParent(parent)
+private ObjectAnimator getBackgroundAnimator() {
+    boolean allowBlurringLauncher = mLauncher.getStateManager().getState() != OVERVIEW
+            && BlurUtils.supportsBlursOnWindows();
+
+    LaunchDepthController depthController = new LaunchDepthController(mLauncher);
+    ObjectAnimator backgroundRadiusAnim = ObjectAnimator.ofFloat(depthController.stateDepth,
+                    MULTI_PROPERTY_VALUE, BACKGROUND_APP.getDepth(mLauncher))
+            .setDuration(APP_LAUNCH_DURATION);
+
+    if (allowBlurringLauncher) {
+        View rootView = mLauncher.getDragLayer();
+
+        // Create a composite SurfaceControl layer for everything behind the app animation
+        ViewRootImpl viewRootImpl = rootView.getViewRootImpl();
+        SurfaceControl parentSurface = viewRootImpl != null ? viewRootImpl.getSurfaceControl() : null;
+
+        if (parentSurface != null) {
+            SurfaceControl blurLayer = new SurfaceControl.Builder()
+                    .setName("Blur Layer")
+                    .setParent(parentSurface)
                     .setOpaque(false)
-                    .setHidden(false)
                     .setEffectLayer()
                     .build();
 
-            backgroundRadiusAnim.addListener(AnimatorListeners.forEndCallback(() ->
-                    new SurfaceControl.Transaction().remove(dimLayer).apply()));
+            SurfaceControl.Transaction transaction = new SurfaceControl.Transaction();
+
+            // Create an animator for the blur effect
+            backgroundRadiusAnim.addUpdateListener(animation -> {
+
+        if (mLauncher.getStateManager().getState() == LauncherState.ALL_APPS) {
+            return;
         }
+                float animatedValue = (float) animation.getAnimatedValue();
+                float blurRadius = Math.min(100f, animatedValue * 100f); // Scale blur with animation progress
+
+                // Dynamically update blur radius
+                if (blurLayer != null && blurLayer.isValid()) {
+                    transaction.setBackgroundBlurRadius(blurLayer, (int) blurRadius);
+                    transaction.setAlpha(blurLayer, 1f);
+                    transaction.show(blurLayer);
+                    transaction.apply();
+                }
+            });
+
+            backgroundRadiusAnim.setInterpolator(new ExponentialEaseOutInterpolator());
+
+            // Cleanup on animation end or cancel
+            backgroundRadiusAnim.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    cleanupBlurLayer(blurLayer, transaction);
+                }
 
-        backgroundRadiusAnim.addListener(
-                AnimatorListeners.forEndCallback(() -> {
-                    // reset the depth to match the main depth controller's depth
-                    depthController.stateDepth
-                            .setValue(mLauncher.getDepthController().stateDepth.getValue());
-                    depthController.dispose();
-                }));
+                @Override
+                public void onAnimationCancel(Animator animation) {
+                    cleanupBlurLayer(blurLayer, transaction);
+                }
 
-        return backgroundRadiusAnim;
+                private void cleanupBlurLayer(SurfaceControl blurLayer, SurfaceControl.Transaction transaction) {
+                    if (blurLayer != null && blurLayer.isValid()) {
+                        transaction.remove(blurLayer).apply();
+                        blurLayer.release(); // Release the SurfaceControl to avoid leaks
+                    }
+                }
+            });
+        }
     }
 
+    backgroundRadiusAnim.addListener(
+            AnimatorListeners.forEndCallback(() -> {
+                depthController.stateDepth
+                        .setValue(mLauncher.getDepthController().stateDepth.getValue());
+                depthController.dispose();
+            }));
+
+    return backgroundRadiusAnim;
+}
+
+
+
+
+
     /**
      * Registers remote animations used when closing apps to home screen.
      */
-- 
2.39.2

